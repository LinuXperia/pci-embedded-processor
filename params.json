{"name":"µPCI","tagline":"Implementação em VHDL de um microcontrolador simplificado","body":"µPCI\r\n======================\r\n\r\n> Inspiração: Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) \r\n\r\n2014-1, Prototipação de Circuitos Integrados. POLI/UPE.\r\n\r\n## Introdução\r\n\r\nTODO\r\n\r\n## Implementação\r\n\r\n### Modelo Estrutural\r\n\r\nTODO\r\n\r\n### Conjunto de Instruções\r\n\r\n| Comando\t\t\t| Opcode (Binary)\t|\r\n|-------------------|-------------------|\r\n| LOAD endereço\t\t| 0000\t\t\t\t|\r\n| STORE endereço\t| 0001\t\t\t\t|\r\n| ADD endereço\t\t| 0010\t\t\t\t|\r\n| SUB endereço\t\t| 0011\t\t\t\t|\r\n| INC\t\t\t\t| 0100\t\t\t\t|\r\n| DEC\t\t\t\t| 0101\t\t\t\t|\r\n| NOT\t\t\t\t| 0110\t\t\t\t|\r\n| AND endereço\t\t| 0111\t\t\t\t|\r\n| OR endereço\t\t| 1000\t\t\t\t|\r\n| XOR endereço\t\t| 1001\t\t\t\t|\r\n| BE endereço\t\t| 1010\t\t\t\t|\r\n| BNE endereço\t\t| 1011\t\t\t\t|\r\n| BG endereço\t\t| 1100\t\t\t\t|\r\n| BL endereço\t\t| 1101\t\t\t\t|\r\n| WAIT\t\t\t\t| 1110\t\t\t\t|\r\n| NOP\t\t\t\t| 1111\t\t\t\t|\r\n\r\n![Structural Model of the Microprocessor](/structural-model.png?raw=true \"Structural Model of the Microprocessor\")\r\n\r\n### Program Counter (PC)\r\n\r\nO módulo do PC deve conter 6 'pinos':\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Barramento de entrada e saída (PC_bus, barramento INOUT);\r\n* Incrementar (PC_inc);\r\n* Carregar (PC_load);\r\n* Ler (PC_valid, manda o valor do PC pro PC_bus quando ativo, ou Z quando inativo).\r\n\r\nTodos devem ser std logic, com exceção do PC_bus, que é std logic vector.\r\n\r\nParte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do PC deve ir para 0.\r\n\r\nParte síncrona: na borda de subida, verifica-se as flags inc e load, em ordem de precedência. Isto é, se inc estiver em nível alto, não importa se load também está, deve ser realizado o incremento. Se inc estiver em nível baixo, verifica-se se load está em nível alto. Se estiver, carrega-se o valor do bus no PC. \r\n\r\n\r\n### Instruction Register\r\n\r\nO módulo do IR deve conter 7 'pinos':\r\n* Clock;\r\n* Reset;\r\n* IR_load (flag para dizer se o IR está no modo load - carregar a instrução a ser executada pelo processador ou decodificada);\r\n* IR_valid (flag que indica se o IR está em operação);\r\n* IR_address (flag para dizer se o IR está address - carregar o endereço no barramento);\r\n* IR_opcode (saída com o opcode decodificado);\r\n* IR_bus (interface para o barramento interno);\r\n\r\nA função do IR é decodificar o *opcode* em forma binária e então passá-lo para o bloco de controle.\r\n\r\nParte assíncrona: se a flag de valid for para 0, a saída no BUS deve ser colocada em Z imediatamente. Se reset for para 0, o valor do registrador interno deve ir para 0s.\r\n\r\nParte síncrona: na borda de subida, o valor do barramento deve ser enviado para o registrador interno e o opcode de saída deve ser decodificado assincronamente quando o valor no IR mudar.\r\n\r\n### Arithmetic Logic Unit (ALU)\r\n\r\nO módulo de ALU deve conter, também, 6 'pinos':\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Barramento de entrada e saída (ALU_bus, barramento INOUT, mesma idéia do PC_bus);\r\n* Comando (função) a ser realizado (ALU_cmd, com 3 bits, sinais de controle que indicam a função (de 8 possíveis) a ser realizada pela ALU);\r\n* Ler (ALU_valid, manda o valor da ALU pro ALU_bus quando ativo, ou Z quando inativo);\r\n* Zero (ALU_zero, fica em nível alto quando o resultado da ALU é todo zero).\r\n\r\nA ALU possui, como sinal interno, um acumulador ACC do tamanho do barramento do sistema. É ele quem guarda o valor a ser enviado para o barramento quando o sinal ALU_valid está ativo, e é quando este é inteiramente zero que o ALU_zero é ativo. Ao ativar o sinal de reset (colocando-o em 0), reseta-se o valor do registrador interno (ACC) para 0.\r\n\r\nNa borda de subida do clock, decodifica-se o valor do comando e realiza-se a operação em cima do ACC.\r\n\r\nOs comandos possíveis são:\r\n\r\n| Comando\t| Operação \t\t\t\t\t\t\t\t\t\t\t\t\t|\r\n|-----------|-----------------------------------------------------------|\r\n| 000 \t\t| Carrega o valor do barramento no ACC (ACC = 0 + BUS) \t\t|\r\n| 001 \t\t| Soma o valor do barramento ao ACC (ACC = ACC + BUS) \t\t|\r\n| 010 \t\t| NOT do valor do barramento (ACC = not BUS) \t\t\t\t|\r\n| 011 \t\t| OR do valor do barramento com o ACC (ACC = ACC or BUS) \t|\r\n| 100 \t\t| AND do valor do barramento com o ACC (ACC = ACC and BUS) \t|\r\n| 101 \t\t| XOR do valor do barramento com o ACC (ACC = ACC xor BUS) \t|\r\n| 110 \t\t| Incrementa o ACC (ACC = ACC + 1) \t\t\t\t\t\t\t|\r\n| 111 \t\t| Armazena o valor do ACC no barramento (BUS = ACC) \t\t|\r\n\r\n### Memória de Programa/Dados\r\n\r\nO módulo de memória deve conter 8 'pinos':\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Ativação de carregamento do registrador MDR (MDR_load, MDR = Memory Data Register);\r\n* Ativação de carregamento do registrador MAR (MAR_load, MAR = Memory Address Register);\r\n* Ler (MEM_valid, manda o valor lido na memória (registrador MDR) para o MEM_bus quando ativo, ou Z quando inativo);\r\n* Barramento de entrada e saída (MEM_bus, barramento INOUT, mesma idéia do PC_bus);\r\n* Flag de ativação da memória (MEM_en);\r\n* Flag de indicação de escrita ou leituar (MEM_rw, onde '0' indica leitura e '1' escrita);\r\n\r\nO bloco de memória tem 3 partes:\r\n* Carregamento do endereço a ser acessado (vem do BUS e é salvo no MAR);\r\n* Leitura ou escrita do dado presente no endereço indicado pelo MAR, utilizando o MDR;\r\n* Carregamento dos dados padrões na memória (simulando ROM), toda vez que a mesma é resetada.\r\n \r\n\r\n### Unidade de Controle (UC)\r\n\r\nA função da Unidade de Controle é acessar o PC, pegar a instrução da memória, mover os dados quando necessário, configurando todos os sinais de controle no momento certo e com os valores corretos.\r\nDessa forma, a Unidade de Controle deve ter um clock e reset, conexão com o barramento global e saídas com todos sinais de controle:\r\n\r\n* Clock;\r\n* Reset ativo em 0;\r\n* Opcode;\r\n* IR_load;\r\n* IR_valid;\r\n* IR_address;\r\n* PC_inc;\r\n* PC_load;\r\n* PC_valid;\r\n* MDR_load;\r\n* MDR_valid;\r\n* MAR_load;\r\n* MAR_valid;\r\n* MEM_en;\r\n* MEM_rw;\r\n* ALU_valid;\r\n* ALU_load;\r\n* ALU_cmd;\r\n* CONTROL_bus;\r\n\r\nA Unidade de controle pode ser implementada por uma máquina de estado que controla o fluxo de sinais no processador. O diagrama da máquina de estado pode ser conferido na imagem abaixo.\r\n\r\n![Basic Processor Controller State Machine](/controller-state-machine.png?raw=true \"Basic Processor Controller State Machine\")\r\n\r\n*Acreditamos que a imagem está repleta de erros. Segue uma tabela do que seriam os sinais corretamente ativos em cada estado.*\r\n\r\n| Estado \t\t| Descrição | Sinais Ativos |\r\n|---|---|---|\r\n| s0 | Busca de instrução: manda o valor do PC para o barramento e incrementa o PC. Além disso, carrega o endereço do barramento (valor do PC) no MAR. | MAR_load, PC_valid, PC_inc |\r\n| s1 | Busca de instrução: ativa memória para R/W e configura para leitura (valor no endereço de memória que está em MAR é armazenado em MDR, isto é, carregamos a próxima linha de código a ser executada). | MEM_en |\r\n| s2 | Busca de instrução/Decodificação: Carregamento do que foi lido na memória para o IR | MEM_valid, IR_load |\r\n| s3 | Envio do valor armazenado em IR para o barramento, carregando no MAR | IR_valid, MAR_load |\r\n| s4 | Se a instrução for de STORE, armazena o valor do acumulador no MDR | ALU_valid, MDR_load |\r\n| s5 | Escreve o valor armazenado no MDR na posição de memória armazenada na MAR | MEM_en, MEM_rw |\r\n| s6 | Se a instrução for diferente de STORE, carrega para MDR o valor da posição de memória armazenado na MAR | MEM_en |\r\n\r\nOs estados s7, s8, s9 e s10 estão incorretos. Após o s6, cria-se um novo estado para cada operação possível que depende da ALU, ativando o flag que envia o valor armazenado na MDR para o barramento, e setando o comando da ALU para a operação correspondente. \r\n\r\nIsto é, para o estado de LOAD, ativa-se MDR_valid e define-se ALU_cmd <= 000. Para ADD, ativa-se MDR_valid e define-se ALU_cmd <= 001. Assim sucessivamente.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}